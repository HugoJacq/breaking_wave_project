'''
This file gather diagnostics for a Basilisk simulation.

References (and associated codes): 

Popinet, S. (2020). A vertically-Lagrangian, non-hydrostatic, multilayer model 
for multiscale free-surface flows. Journal of Computational Physics, 418, 
109609. https://doi.org/10.1016/j.jcp.2020.109609

Wu, J., Popinet, S., & Deike, L. (2023). Breaking wave field statistics with a 
multi-layer model. Journal of Fluid Mechanics, 968, A12. 
https://doi.org/10.1017/jfm.2023.522

Wu, J., Popinet, S., Chapron, B., Farrar, J. T., & Deike, L. (2025). Turbulence
and Energy Dissipation from Wave Breaking. Journal of Physical Oceanography, 
55(9), 1521â€‘1534. https://doi.org/10.1175/JPO-D-25-0052.1
'''

import numpy as np
import gc
import xarray as xr
from scipy.interpolate import interp1d

def grad_velocities(ds, grid):
    '''
    Computes the gradient of velocities from a velocity field named u.x u.y u.z
    '''
    delta = ds.x[1]-ds.x[0]
    dudx = grid.interp(grid.diff(ds['u.x'], 'X'), 'X')/delta
    dudy = grid.interp(grid.diff(ds['u.x'], 'Y'), 'Y')/delta
    dudzl = grid.interp(grid.diff(ds['u.x'], 'Z'), 'Z')
    dvdx = grid.interp(grid.diff(ds['u.y'], 'X'), 'X')/delta
    dvdy = grid.interp(grid.diff(ds['u.y'], 'Y'), 'Y')/delta
    dvdzl = grid.interp(grid.diff(ds['u.y'], 'Z'), 'Z')
    dwdx = grid.interp(grid.diff(ds['u.z'], 'X'), 'X')/delta
    dwdy = grid.interp(grid.diff(ds['u.z'], 'Y'), 'Y')/delta
    dwdzl = grid.interp(grid.diff(ds['u.z'], 'Z'), 'Z')
    
    dzdx = grid.interp(grid.diff(ds.z, 'X'), 'X')/delta
    dzdy = grid.interp(grid.diff(ds.z, 'Y'), 'Y')/delta
    dzdzl = grid.interp(grid.diff(ds.z, 'Z'), 'Z')

    ds['dudz'] = (dudzl/dzdzl).compute()
    ds['dudy'] = (dudy - ds['dudz']*dzdy).compute()
    ds['dudx'] = (dudx - ds['dudz']*dzdx).compute()
    ds['dvdz'] = (dvdzl/dzdzl).compute()
    ds['dvdy'] = (dvdy - ds['dvdz']*dzdy).compute()
    ds['dvdx'] = (dvdx - ds['dvdz']*dzdx).compute()
    ds['dwdz'] = (dwdzl/dzdzl).compute()
    ds['dwdy'] = (dwdy - ds['dwdz']*dzdy).compute()
    ds['dwdx'] = (dwdx - ds['dwdz']*dzdx).compute()
    
    print('Field gradient computed!')
    
    del(dudx, dudy, dudzl, dvdx, dvdy, dvdzl, dwdx, dwdy, dwdzl, dzdx, dzdy, dzdzl)
    gc.collect()

    return ds

def vorticity(ds, grid):   
    '''
    Computes vorticity (squared) from a velocity field named u.x u.y u.z and a xgcm grid
    '''
    if 'dudx' not in ds.keys():
        ds = grad_velocities(ds, grid)

    ds['omegaxp'] = ds.dwdy - ds.dvdz
    ds['omegayp'] = ds.dudz - ds.dwdx
    ds['omegazp'] = ds.dvdx - ds.dudy
    ds['enstrophy'] = 1/2 * (ds.omegaxp**2 + ds.omegayp**2 + ds.omegazp**2)
    return ds

def dissipation(ds, grid):
    '''
    Computes dissipation from a velocity field named u.x u.y u.z and a xgcm grid
    '''

    if 'dudx' not in ds.keys():
        ds = grad_velocities(ds, grid)
    ds['epsilon'] = 2*(ds.dudx**2 + 
        2*((ds.dudy + ds.dvdx)/2.)**2 + 
        2*((ds.dudz+ds.dwdx)/2.)**2 + 
        ds.dvdy**2 + 
        2*((ds.dvdz+ds.dwdy)/2.)**2 + 
        ds.dwdz**2)
    return ds



# ufunc for z interpolation
# (from Jiarong)
class interp1d_class():
    def __init__(self, znew, fill_value):
        self.znew = znew
        self.fill_value = fill_value
    def __call__(self, x, y):
        f = interp1d(x, y, kind='linear', fill_value=self.fill_value, bounds_error=False)
        return f(self.znew)
    
''' fill_value: array-like or (array-like, array_like) or 'extrapolate' '''
interpz = lambda znew, z, ds, fill_value: xr.apply_ufunc (
    interp1d_class(znew, fill_value),
    #lambda x, y: interpolate_1d(x, y, znew),  # The function to apply if interpolate_1d is not defined as a class
    z,  # Original vertical coordinates
    ds,  # Data (Dataarray or Dataset) to interpolate
    input_core_dims=[['zl'], ['zl']],  # Core dimensions for each input
    output_core_dims=[['zl']],  # Core dimensions for the output
    exclude_dims=set(('zl',)),
    dask_gufunc_kwargs={'output_sizes':{'zl':len(znew)}},
    output_dtypes=['float32'],
    vectorize=True,  # Enable vectorization
    dask="parallelized",  # Parallelize using Dask if the data is large
)
